//
//  JTStatusMenu.m
//  JobTracker
//
//  Created by Brad Greenlee on 10/21/12.
//  Copyright (c) 2012 Etsy. All rights reserved.
//

#import "JTStatusMenu.h"
#import "JTState.h"

@implementation JTStatusMenu

@synthesize jobTrackerURL, usernames, refreshInterval, startingJobNotificationsEnabled, completedJobNotificationsEnabled,
failedJobNotificationsEnabled, cdhVersion;

- (void)awakeFromNib {
    statusItem = [[NSStatusBar systemStatusBar] statusItemWithLength:NSVariableStatusItemLength];
    statusImage = [NSImage imageNamed:@"pith helmet small.png"];
    [statusItem setImage:statusImage];
    [statusItem setAlternateImage:statusHighlightImage];
    [statusItem setHighlightMode:YES];
    [statusMenu setAutoenablesItems:NO];
    [statusItem setMenu:statusMenu];
    
    // Listen for events when the computer wakes from sleep, which otherwise
    // throws off the refresh schedule.
    [[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self
                                                           selector:@selector(receiveWakeNote:)
                                                               name:NSWorkspaceDidWakeNotification
                                                             object:nil];
    
    [GrowlApplicationBridge setGrowlDelegate:self];
    
    [self loadPreferences];
    if ([self isConfigured]) {
        jtState = [JTState sharedInstance];
        NSString *urlSuffix = cdhVersion == 4 ? @"/jobtracker.jsp" :  @"/ws/v1/cluster/apps";
        jtState.url = [NSURL URLWithString:[jobTrackerURL stringByAppendingString: urlSuffix]];
        [jtState setUsernameString:usernames];
        jtState.delegate = self;
        [self refresh:nil];
        [self startTimer];
    } else {
        [self showPreferences:nil];
    }
}

- (id)init {
    if ((self = [super init])) {
        [self loadPreferences];
    }
    return self;
}

- (void)loadPreferences {
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    // this replace just fixes the url generated by an earlier version and can eventually be removed
    
    jobTrackerURL = [[defaults stringForKey:@"jobTrackerURL"] stringByReplacingOccurrencesOfString:@"/jobtracker.jsp" withString:@""];
    if ([jobTrackerURL length] > 7 && !([[jobTrackerURL substringToIndex:7] isEqualToString:@"http://"] ||
        [[jobTrackerURL substringToIndex:8] isEqualToString:@"https://"]))
    {
        jobTrackerURL = [@"http://" stringByAppendingString:jobTrackerURL];
    }
    usernames = [defaults stringForKey:@"usernames"];
    refreshInterval = [defaults integerForKey:@"refreshInterval"];
    if (refreshInterval == 0) {
        refreshInterval = DEFAULT_REFRESH_INTERVAL;
    }
    startingJobNotificationsEnabled = [defaults boolForKey:@"startingJobNotificationsEnabled"];
    completedJobNotificationsEnabled = [defaults boolForKey:@"completedJobNotificationsEnabled"];
    failedJobNotificationsEnabled = [defaults boolForKey:@"failedJobNotificationsEnabled"];
    cdhVersion = [defaults integerForKey:@"cdhVersion"];
}

- (NSWindowController *)preferencesWindowController {
    if (_preferencesWindowController == nil) {
        _preferencesWindowController = [[JTPreferencesWindowController alloc] init];
        _preferencesWindowController.delegate = self;
    }
    return _preferencesWindowController;
}

- (IBAction)showPreferences:(id)sender {
    #pragma unused (sender)
    [self.preferencesWindowController showWindow:nil];
}

- (BOOL)isConfigured {
    if (self.jobTrackerURL == nil || [self.jobTrackerURL isEqualToString:@""]) {
        return NO;
    }
    return YES;
}

- (void)startTimer {
    [self stopTimer];
    
    refreshTimer = [NSTimer scheduledTimerWithTimeInterval:refreshInterval
                                                    target:self
                                                  selector:@selector(refresh:)
                                                  userInfo:nil
                                                   repeats:YES];
}


- (void)stopTimer {
    if (refreshTimer != nil) {
        [refreshTimer invalidate];
        refreshTimer = nil;
    }
}

- (void)receiveWakeNote:(NSNotification*)note {
    #pragma unused (note)
    if ([self isConfigured]) {
        // Kill off the current refresh schedule.
        [self stopTimer];
        
        // Wait a bit after wake before refreshing, so we don't make wake slower.
        [NSTimer scheduledTimerWithTimeInterval:10.0
                                         target:self
                                       selector:@selector(refresh:)
                                       userInfo:nil
                                        repeats:NO];
        
        // Reset the refresh schedule after the wake refresh.
        [self startTimer];
    }
}

- (IBAction)refresh:(id)sender {
    #pragma unused (sender)
    [self startRefresh];
    [jtState refresh];
    if (jtState.currentError) {
        [self setError:jtState.currentError];
    } else {
        [self clearError];
    }
}

- (void)setError:(NSError *)error {
    // right now we're not actually looking at error since there's only one error we're raising
    // (url can't be reached), but we will probably want to handle others in the future (e.g. parsing error)
    #pragma unused (error)
    NSMenuItem *refresh = [statusMenu itemWithTag:REFRESH_TAG];
    NSDictionary *attrDict = [NSDictionary dictionaryWithObjectsAndKeys:
                                [NSFont boldSystemFontOfSize:13.0], NSFontAttributeName,
                                [NSColor redColor], NSForegroundColorAttributeName, nil];
    NSAttributedString *errorString = [[NSAttributedString alloc] initWithString:@"Error: Please check your JobTracker URL" attributes:attrDict];
    [refresh setAttributedTitle:errorString];
    [refresh setEnabled:NO];
    
    [statusItem setImage:[NSImage imageNamed:@"pith helmet error.png"]];
}

-(void)clearError {
    [[statusMenu itemWithTag:REFRESH_TAG] setAttributedTitle:nil];
    [statusItem setImage:[NSImage imageNamed:@"pith helmet small.png"]];
}

- (void)stateUpdated {
    [self updateMenuItemWithTag:RUNNING_JOBS_TAG withJobs:[jtState.jobs objectForKey:@"running"]];
    [self updateMenuItemWithTag:COMPLETED_JOBS_TAG withJobs:[jtState.jobs objectForKey:@"completed"]];
    [self updateMenuItemWithTag:FAILED_JOBS_TAG withJobs:[jtState.jobs objectForKey:@"failed"]];
    [self endRefresh];
}

- (void) growlNotificationWasClicked:(id)clickContext {
    NSString *jobId = [clickContext objectForKey:@"jobId"];
    [self openJobInBrowser:jobId];
}

- (void)sendNotificationWithTitle:(NSString *)title withJob:(JTJob *)job {
    [GrowlApplicationBridge notifyWithTitle:title
                                description:job.displayName
                           notificationName:title
                                   iconData:nil
                                   priority:0
                                   isSticky:NO
                               clickContext:[NSDictionary dictionaryWithObject:job.jobId forKey:@"jobId"]];
}

- (void)jobStarted:(JTJob *)job {
    if (startingJobNotificationsEnabled) {
        [self sendNotificationWithTitle:@"Job Started" withJob:job];
    }
}

- (void)jobCompleted:(JTJob *)job {
    if (completedJobNotificationsEnabled) {
        [self sendNotificationWithTitle:@"Job Completed" withJob:job];
    }
}

- (void)jobFailed:(JTJob *)job {
    if (failedJobNotificationsEnabled) {
        [self sendNotificationWithTitle:@"Job Failed" withJob:job];
    }
}

- (void)startRefresh {
    NSMenuItem *refresh = [statusMenu itemWithTag:REFRESH_TAG];
    [refresh setTitle:@"Refreshing..."];
    [refresh setEnabled:NO];
}

- (void)endRefresh {
    NSMenuItem *refresh = [statusMenu itemWithTag:REFRESH_TAG];
    [refresh setTitle:@"Refresh"];
    [refresh setEnabled:YES];
}

- (void)updateMenuItemWithTag:(NSInteger)tag withJobs:(NSArray *)jobs {
    NSMenu *jobsMenu = [[NSMenu alloc] init];
    NSMenuItem *jobsMenuItem = [statusMenu itemWithTag:tag];
    if ([jobs count] == 0) {
        NSMenuItem *noneItem = [[NSMenuItem alloc] init];
        [noneItem setTitle:@"None"];
        [noneItem setEnabled:NO];
        [jobsMenu addItem:noneItem];
    } else {
        for (JTJob *job in jobs) {
            NSMenuItem *jobItem = [[NSMenuItem alloc] initWithTitle:job.displayName action:@selector(jobSelected:) keyEquivalent:@""];
            [jobItem setRepresentedObject:job];
            [jobItem setTarget:self];
            [jobItem setEnabled:YES];
            [jobsMenu addItem:jobItem];
        }
    }
    [statusMenu setSubmenu:jobsMenu forItem:jobsMenuItem];
}

- (void)jobSelected:(id)sender {
    NSMenuItem *menuItem = sender;
    JTJob *job = [menuItem representedObject];
    [self openJobInBrowser:job.jobId];
}

- (void)openJobInBrowser:(NSString *)jobId {
    NSString *formatString = cdhVersion == 4 ? @"%@/jobdetails.jsp?jobid=%@" : @"%@/cluster/app/%@";
    NSString *jobUrl = [NSString stringWithFormat:formatString, jobTrackerURL, jobId];
    [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:jobUrl]];
}

- (IBAction)openInBrowser:(id)sender {
    #pragma unused (sender)
    NSString *urlSuffix = cdhVersion == 4 ? @"/jobtracker.jsp" :  @"/cluster";
    [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:[jobTrackerURL stringByAppendingString:urlSuffix]]];
}

- (void)preferencesUpdated {
    [self loadPreferences];
    if ([self isConfigured]) {
        jtState = [JTState sharedInstance];
        NSString *urlSuffix = cdhVersion == 4 ? @"/jobtracker.jsp" :  @"/ws/v1/cluster/apps";
        jtState.url = [NSURL URLWithString:[jobTrackerURL stringByAppendingString: urlSuffix]];
        [jtState setUsernameString:usernames];
        jtState.delegate = self;
        [self refresh:nil];
        [self startTimer];
    } else {
        [self showPreferences:nil];
    }
}

- (void)handleServices:(NSPasteboard *)pboard
              userData:(NSString *)userData
                 error:(NSString **)error {
    
#pragma unused (userData)
    // Get the string.
    NSString *pboardString = [pboard stringForType:NSPasteboardTypeString];
    NSString *trimmedPboardString = [pboardString stringByTrimmingCharactersInSet: [NSCharacterSet whitespaceCharacterSet]];
    if ([trimmedPboardString rangeOfString:@"job_\\d+" options:NSRegularExpressionSearch].location != NSNotFound) {
        [self openJobInBrowser:trimmedPboardString];
    } else {
        *error = NSLocalizedString(@"Error: invalid job id.",
                                   @"job id didn't match the expected format.");
    }
}

// growl delegate method
- (BOOL) hasNetworkClientEntitlement {
    return YES;
}

@end
